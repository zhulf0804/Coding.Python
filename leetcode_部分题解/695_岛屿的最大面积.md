给定一个包含了一些0和1的非空二维数组grid，一个岛屿是由四个方向(水平或垂直)的1(代表土地)构成的组合。你可以假设二维矩阵中的四个边缘都被水围绕着。

找到给定的二维数组中最大的岛屿面积。（如果没有岛屿，则返回面积为0）

**示例 1:**
```
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
```
对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。

**示例 2:**
```
[[0,0,0,0,0,0,0,0]]
```
对于上面这个给定的矩阵, 返回 0。

**注意:** 给定的矩阵grid 的长度和宽度都不超过 50。

看到这个题目很自然的想到深度优先搜索。但是即使有了大致的思路，写出的程序**仍旧不能一次就通过(会有小bug)**，而且**不能快速的写出**。这是为什么呢?

这里想通过这个简单的题目继续理一下深度优先搜索(DFS)的思想。

矩阵中的1可以通过位置关系构成一个图G，一个岛屿就是一个连通区域，岛屿的最大面积就是连通区域的最大节点的个数。所以需要遍历每一个连同区域。在矩阵中，思路大致如下:

+ 遍历矩阵中的元素，从未被访问的且为1的位置(i, j)开始遍历，找到其最大面积area(相邻接的1的个数)。[**核心就是计算包含(i, j)位置的连通区域的面积**，递归实现]
    + 如果它的位置在矩阵之外，返回0
    + 如果它被访问过，则返回0。（这一步很关键，防止陷入循环调用，而且这样设置是有效的）
    + 如果它未被访问过，则
        + 标志其被访问
        + 如果其值为0，则返回0
        + 如果其值为1，则计算(i-1, j), (i+1, j), (i, j-1), (i, j+1)的最大面积。
+ 更新最大的面积max_area

代码如下:

```
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        mmax_area = 0
        m, n = len(grid), len(grid[0])
        visited = [[0] * n for _ in range(m)]
        def helper(x, y):
            if x < 0 or x >= m or y < 0 or y >= n:
                return 0
            if visited[x][y]:
                return 0
            visited[x][y] = 1
            if grid[x][y] == 0:
                return 0
            return 1 + helper(x - 1, y) + helper(x + 1, y) + helper(x, y - 1) + helper(x, y + 1)
        for i in range(m):
            for j in range(n):
                if not visited[i][j] and grid[i][j] == 1:
                    area = helper(i, j)
                    if area > mmax_area:
                        mmax_area = area
        return mmax_area
```
